# Clarifying Questions — Agent Reasoning Summary

**To relay to the user before finalizing the spec.**

---

## Primary Questions

These are decision-critical and block spec finalization.

1. **Granularity of "rationale"** — Should the rationale per tool call be the raw `ToolSelection.reasoning` string (the model's own words, already available at call time), or should it be a separately generated summary sentence produced *after* the tool result is known? The former is free; the latter requires an extra LLM call.

2. **Turn narrative: LLM-generated or rule-based?** — Should the 2–4 sentence turn summary be generated by calling the LLM once per turn (adds latency + cost), or assembled deterministically from the tool-call log (fast, cheap, but formulaic, e.g. "Searched memory, then wrote a file; succeeded")?

3. **CLI presentation mode** — Should reasoning be shown:
   - (a) automatically after every turn (always on),
   - (b) only in `/debug` mode (already togglable in the REPL),
   - (c) via a new explicit REPL command like `/reasoning` that prints the last turn's summary, or
   - (d) some combination (e.g., tool decisions inline during execution + `/reasoning` for the narrative)?

4. **HTTP endpoint design** — Preferred shape of the API response? Options:
   - Flat: `GET /api/threads/{thread_id}/turns/{n}/reasoning` → single JSON object
   - Paginated list: `GET /api/threads/{thread_id}/reasoning` → array of all turns
   - Inline on existing turn endpoint: extend the existing thread/turn response to include a `reasoning` field
   Which do you prefer, or should the spec propose all three?

5. **Rationale for tool *parameters*** — When the agent picks a tool and crafts parameters, should the summary explain *what* the parameters mean (e.g., "searched memory for 'project goals'"), or just show the raw parameter JSON plus the tool name? The former requires interpretation; the latter is mechanical.

6. **Safety boundary for the reasoning text** — The `ToolSelection.reasoning` string is model-produced and may contain echoed user content or fragments of context. Should it pass through the full `SafetyLayer` (sanitizer + leak detector), or just the `LeakDetector` (credential scrubbing only)? The full layer may mangle useful phrasing.

7. **Scope: chat-loop only vs. also worker jobs?** — The parent task says "chat dispatcher" initially. Should the spec explicitly gate out the background `worker.rs` job loop (which has its own action log in `JobAction`/`ConversationMemory`), or treat chat+job reasoning as a future extension to mention but not design now?

8. **Retention policy** — Since this is in-memory only: should reasoning entries be dropped per-turn after a configurable number of turns (e.g., last 20), or kept for the full lifetime of the in-memory session? Any concern about memory growth for long-running sessions?

9. **Thread vs. session scope for HTTP** — Should the HTTP endpoint address reasoning by `(session_id, thread_id, turn_number)` or just by `(thread_id, turn_number)`? The existing web server uses both session and thread IDs in different endpoints — which is the natural parent key here?

10. **`/reasoning` vs. extending `/debug`** — The REPL already has `/debug` which increases verbosity. Should reasoning be a sub-mode of `/debug` (less surface area, familiar) or a first-class new command (more discoverable)? Or both (debug shows it inline; `/reasoning [N]` shows historical summary)?

11. **Where to carry the reasoning through the call chain** — `ToolSelection.reasoning` is discarded before it reaches `TurnToolCall.record_tool_call()` (the `RespondResult::ToolCalls` path only carries `id/name/arguments`). The two viable options are: (a) add a `reasoning: Option<String>` field to the `ToolCall` struct in `provider.rs` and thread it through, or (b) store a separate `turn_narrative: Option<String>` on `Turn` from the `content` field of `RespondResult::ToolCalls` (per-turn, not per-tool-call). Which is preferable, or should both be stored?

---

## Follow-up / Lower-priority Questions

These can be deferred if the primary questions above are answered but are worth capturing.

12. **Alternative tools considered** — `ToolSelection.alternatives` exists on the struct but is currently always empty (the LLM doesn't reliably populate it). Should the spec describe a mechanism to prompt for alternatives, or simply omit this field from the summary until it becomes reliable?

13. **Multi-tool parallel execution** — When the agent executes multiple tools in parallel (the `JoinSet` path in `dispatcher.rs`), should the reasoning summary show them grouped ("called 3 tools in parallel: …") or in an arbitrary sequential order?

14. **Naming / command spelling** — Any preference on the REPL command name? `/reasoning`, `/rationale`, `/why`, `/trace`? And the HTTP path segment: `/reasoning`, `/rationale`, `/trace`, `/decisions`?

15. **SSE / streaming** — Should reasoning events be emitted as SSE events to the web gateway (so a UI can show tool decisions as they happen), or is the HTTP endpoint (query after the fact) sufficient for now?

16. **Visual asset** — Do you have any mockups, ASCII diagrams, or screenshots showing the desired CLI output format? (E.g., how tool decisions should be indented relative to the existing `● tool_name` / `● result preview` lines.) A picture here would disambiguate CLI layout quickly.
